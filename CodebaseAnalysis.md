# 코드베이스 분석 보고서

## 1. 개요

이 문서는 DungeonMaster 프로젝트의 `Assets/Scripts` 폴더 내 모든 C# 스크립트에 대한 심층 분석 결과를 담고 있습니다. 분석의 목적은 코드베이스의 현재 아키텍처를 이해하고, 잠재적인 문제점을 식별하며, 향후 진행될 리팩토링의 우선순위와 방향을 설정하는 것입니다.

## 2. 전반적인 아키텍처 평가

프로젝트는 전반적으로 뛰어난 아키텍처 원칙에 따라 설계되었습니다.

### 2.1. 강점 (잘 설계된 부분)

*   **결정론적 전투 시스템**: `BattleState`의 불변성(Immutability)과 `IAction` 기반의 원자적 상태 변화 로직은 프로젝트의 가장 큰 강점입니다. 이는 예측 가능하고 테스트가 용이하며, 재현 가능한 전투 환경을 보장합니다.
*   **유연한 데이터 설계 (`ScriptableObject`)**: 카드, 스킬, 장비, 각종 게임 설정 등 대부분의 디자인 데이터를 `ScriptableObject`로 분리하여 코드와 데이터를 효과적으로 분리했습니다. 이는 디자이너의 작업 효율을 높이고 코드의 유연성을 확보하는 좋은 설계입니다.
*   **SOLID 원칙의 적극적인 활용**:
    *   **지역화 시스템**: `LocalizationCore`와 `LocalizationManager`의 분리, `ILocalizationLogger` 인터페이스를 통한 의존성 역전 등은 매우 모범적인 사례입니다.
    *   **스케일링 시스템**: 전략 패턴과 팩토리 패턴을 활용하여, 레벨에 따른 값의 변화 로직을 매우 유연하고 확장 가능하게 구축했습니다.
    *   **데미지 계산 파이프라인**: `IDamageCalculationStep` 인터페이스를 통해 데미지 계산 과정을 여러 단계로 분리한 것은 개방-폐쇄 원칙(OCP)을 잘 따른 훌륭한 설계입니다.
*   **효과적인 에디터 스크립팅**: `UniqueEffectSOEditor`의 `ReorderableList`와 `SerializeReference` 활용, `StringTableCsvImporter`를 통한 데이터 임포트 기능 등은 개발 및 디자인 워크플로우를 크게 개선하는 유용한 도구입니다.

### 2.2. 개선이 필요한 핵심 아키텍처 문제

분석 결과, 프로젝트의 안정성과 확장성을 저해할 수 있는 심각한 아키텍처 문제들이 여러 곳에서 발견되었습니다. 이 문제들은 서로 얽혀 있으며, 리팩토링 시 최우선으로 해결해야 합니다.

1.  **성장 시스템의 파편화 및 충돌 (심각도: 최상)**
    *   **문제**: 캐릭터 성장 로직이 `CharacterGrowthSystem`, `GrowthManager`, `ResourceManager` 세 곳에 분산되어 있으며, 일부는 결정론적 원칙을 위배(`UnityEngine.Random` 사용)하여 서로 충돌하고 있습니다.
    *   **영향**: 스탯 계산 오류, 예측 불가능한 성장, 유지보수 비용 급증.
    *   **권장 해결책**: 세 시스템의 역할을 명확히 재정의하고, **하나의 통합된, 결정론적인 성장 관리 시스템**으로 통합해야 합니다.

2.  **데이터 관리 시스템의 중복**
    *   **문제**: 동일한 목적으로 보이는 데이터베이스 클래스가 중복으로 존재합니다. (예: `Equipment/GlobalMonsterEquipmentManager` vs. `Managers/EquipmentManager`)
    *   **영향**: 어떤 시스템을 사용해야 할지 혼란 야기, 데이터 불일치 가능성, 유지보수 비효율.
    *   **권장 해결책**: `Resources.LoadAll`을 사용하는 자동화된 방식으로 역할을 통일하고, 중복되는 클래스는 제거해야 합니다.

3.  **장비 인스턴스 관리 부재**
    *   **문제**: `MonsterEquipmentManager`가 장비의 원본 에셋(`ScriptableObject`)을 직접 장착하여, 개별 장비 인스턴스의 고유한 상태(강화 레벨, 추가 옵션 등)를 저장할 수 없는 치명적인 구조적 결함이 있습니다.
    *   **영향**: 장비 강화, 개조 등 핵심 성장 시스템 구현 불가.
    *   **권장 해결책**: '장비 설계도(`BaseMonsterEquipment`)'와 '장비 인스턴스(`MonsterEquipmentInstance`)' 개념을 명확히 분리하는 리팩토링이 시급합니다.

4.  **위험한 안티패턴 사용**
    *   **문제**: `SkillManager`와 `MonsterWeapon`에서 캡슐화 원칙을 위배하는 **리플렉션(Reflection)**을 사용하여 부모 클래스의 `private` 필드를 강제로 수정하고 있습니다. 또한 `SkillManager`는 사용자 규칙에 명시적으로 금지된 `ScriptableObject.CreateInstance`를 런타임에 사용하여 임시 데이터 객체를 생성하고 있습니다.
    *   **영향**: 유지보수성 급격히 저하, 예측 불가능한 런타임 오류 발생, 프로젝트 안정성 저해.
    *   **권장 해결책**: '기본 공격'을 일반 스킬 에셋으로 만드는 등, 리플렉션과 런타임 인스턴스 생성을 완전히 제거하는 방향으로 전면 재설계해야 합니다.

5.  **결정론적 원칙 위배**
    *   **문제**: `Equipment/PercentStatModifierEffect` 클래스가 `static` 전역 변수를 사용하여 버프 상태를 추적하고 있어, 결정론적 전투 시스템의 상태를 오염시키고 예측 불가능한 결과를 초래할 수 있습니다.
    *   **영향**: 전투 결과의 비일관성, 재현 불가능한 버그 발생.
    *   **권장 해결책**: `static` 변수를 제거하고, 모든 상태가 `BattleState` 내에서 관리되도록 로직을 변경해야 합니다.

## 3. 폴더별 상세 분석 요약

(여기에 각 폴더별 분석 요약을 첨부하여 상세 내용을 참고할 수 있도록 합니다.)

*   **Battle**: 견고한 결정론적 구조. `BattleManager`의 비대화 가능성 존재.
*   **Buff**: 데이터와 로직 분리가 잘 되어있으나, `BuffManager` 등의 싱글톤/정적 클래스가 테스트 용이성을 저해할 수 있음.
*   **Character**: 데이터와 뷰가 잘 분리되어 있으나, '성장 시스템 파편화'라는 가장 심각한 문제를 포함.
*   **Data**: 전반적으로 매우 잘 설계됨. 퍼사드 패턴을 통해 하위 시스템을 잘 조율.
*   **Editor**: 개발 및 디자인 편의성을 크게 향상시키는 유용한 도구들.
*   **Equipment**: 유연한 기반을 갖추고 있으나, '장비 인스턴스 부재', '결정론 위배', '리플렉션 사용' 등 심각한 문제 다수 포함.
*   **Localization**: SOLID 원칙을 훌륭하게 준수한, 리팩토링이 거의 필요 없는 모범적인 시스템.
*   **Managers**: 하위 시스템 총괄. '데이터 관리 중복' 문제와 '테스트 코드 분리 필요' 문제 발견.
*   **Shared**: 전략/팩토리 패턴을 활용한 매우 유연하고 확장성 있는 `Scaling` 시스템.
*   **Skill**: 실행 로직은 훌륭하나, `SkillManager`에서 '리플렉션 사용' 및 '임시 객체 생성' 등 심각한 안티패턴 발견.
*   **Utility**: 작지만 유용한 헬퍼 클래스들을 통해 코드 품질 향상에 기여.

## 4. 결론 및 다음 단계 제안

현재 코드베이스는 뛰어난 아키텍처적 강점을 많이 가지고 있지만, 몇몇 심각한 구조적 문제점들이 프로젝트의 안정성과 확장성을 가로막고 있습니다.

다음 단계로, 위에서 식별된 **5가지 핵심 아키텍처 문제**를 해결하기 위한 구체적인 리팩토링 계획을 수립하고, 사용자에게 제안하여 동의를 얻은 후 계획에 따라 작업을 진행할 것을 권장합니다. 