# 코드베이스 상세 분석 로그 (2024-05-24)

이 문서는 `CodebaseAnalysis.md`의 요약본과 별개로, 각 스크립트 파일에 대한 상세 분석 내용을 기록한 로그입니다.

---

## `Data` 폴더

`Data` 폴더는 게임의 모든 데이터 구조와 데이터 관리 로직의 핵심입니다.

*   **`UserCardCollection.cs` 분석:**
    *   **역할**: 플레이어가 소유한 모든 `UserCardData`를 관리하는 컬렉션. 카드 획득, 조회, 제거 등 카드 인벤토리 역할을 합니다.
    *   **설계**: `[SerializeField]` 리스트와 런타임용 `Dictionary`를 `ISerializationCallbackReceiver`로 동기화하는 매우 효율적이고 안정적인 설계를 보여줍니다. 데이터 저장과 런타임 성능을 모두 잡았습니다.
    *   **리팩토링 관점**: 전반적으로 매우 잘 설계되어 리팩토링이 거의 필요 없습니다.

*   **`UserCardData.cs` 분석:**
    *   **역할**: 개별 카드의 영구적인 성장 상태(레벨, 경험치, 최종 스탯, 고유 성장률)를 담는 순수 데이터 객체(POCO)입니다.
    *   **설계**: `CurrentStats` 필드는 레벨업, 장비 등 모든 효과가 적용된 최종 결과값을 저장하는 중요한 필드입니다. ID 생성 방식이 해시 충돌 가능성이 있으나, 실용적으로는 문제가 크지 않을 수 있습니다.
    *   **리팩토링 관점**: 깔끔한 데이터 클래스이며, 큰 수정은 필요하지 않습니다.

*   **`UserDataManager.cs` 및 `UserData` 분석:**
    *   **역할**: `UserDataManager`는 `SaveDataManager`, `ResourceManager` 등 여러 하위 데이터 시스템을 조율하는 최상위 퍼사드(Facade) 역할을 합니다. `UserData`는 플레이어의 모든 데이터를 담는 최상위 컨테이너입니다.
    *   **설계**: 퍼사드 패턴을 통해 복잡한 하위 시스템을 숨기고 단일 진입점을 제공하여 코드 구조를 매우 깔끔하게 유지합니다. 데이터 변경 시 자동 저장 기능도 포함되어 있습니다.
    *   **리팩토링 관점**: 정적 클래스(`UserDataManager`)의 한계(테스트 어려움)가 있지만, 싱글 플레이어 게임에서는 매우 실용적인 구조입니다. 리팩토링 우선순위는 높지 않습니다.

*   **`ActionInput.cs` 분석:**
    *   **역할**: AI나 플레이어의 행동 '의도'를 나타내는 데이터 전송 객체(DTO)입니다.
    *   **설계**: 행동의 '요청'(`ActionInput`)과 '실행'(`IAction`)을 분리하여 시스템의 유연성을 높입니다. 다중 타겟과 확장 가능한 `ActionType` enum 등 미래 확장성을 고려한 설계가 돋보입니다.

*   **`CardBlueprintData.cs` 분석:**
    *   **역할**: 모든 몬스터 카드의 원본 데이터를 정의하는, 불변의 `ScriptableObject` 설계도입니다.
    *   **설계**: 데이터 기반 설계의 핵심축입니다. `ScriptableObject`를 효과적으로 활용하여 데이터와 로직을 분리하고 디자이너의 작업을 용이하게 하는, 매우 유연하고 강력한 시스템의 기반을 제공합니다.

*   **`LevelingConfig.cs` 분석:**
    *   **역할**: 레벨업 필요 경험치 테이블을 관리하는 `ScriptableObject` 싱글톤입니다.
    *   **리팩토링 관점**: `ScriptableObject` 싱글톤 패턴은 편리하지만, 코드의 특정 경로에 강하게 결합되고 테스트를 어렵게 만드는 단점이 있습니다. 순수 C# 로직에서는 의존성 주입을 사용하는 것이 더 나은 대안입니다.

---

## `Editor` 폴더

`Editor` 폴더의 스크립트들은 Unity 에디터의 기능을 확장하여 개발 편의성을 높이는 역할을 합니다.

*   **`StringTableCsvImporter.cs` 분석:**
    *   **역할**: CSV 파일에 정의된 텍스트와 번역을 `StringTable` 에셋으로 가져오는 에디터 스크립트입니다.
    *   **설계**: `[MenuItem]`으로 에디터에 기능을 추가하고, `AssetDatabase` API를 사용하여 에셋을 안전하게 처리합니다. `Undo` 기능을 지원하는 등 좋은 습관을 보여줍니다.
    *   **리팩토링 관점**: CSV 파싱 로직이 텍스트 내 쉼표(`,`)에 취약할 수 있다는 점, 경로가 하드코딩되었다는 점 등 개선의 여지가 있으나, 현재 기능 수행에는 문제가 없습니다.

*   **`UniqueEffectSOEditor.cs` 분석:**
    *   **역할**: `UniqueEffectSO`의 복잡한 데이터 구조를 인스펙터에서 편리하게 편집하도록 UI를 개선합니다.
    *   **설계**: `[CustomEditor]`, `[CustomPropertyDrawer]`, `ReorderableList`를 능숙하게 활용합니다. 특히 `onAddDropdownCallback`에서 리플렉션과 `SerializeReference`를 조합하여, 코드를 수정하지 않고도 디자이너가 새로운 타입의 조건/액션을 추가할 수 있게 만든 점은 매우 유연하고 확장성 높은 설계의 백미입니다.
    *   **리팩토링 관점**: 매우 잘 만들어진 에디터 스크립트로, 리팩토링이 거의 필요 없습니다.

---

## `Equipment` 폴더

장비 데이터 구조와 관리 시스템을 포함하며, 심각한 아키텍처 문제를 다수 포함하고 있습니다.

*   **`AccessoryData.cs`, `ArmorData.cs` 분석:**
    *   **역할**: `BaseMonsterEquipment`를 상속하는 비어있는 자식 클래스들입니다.
    *   **설계**: 향후 장비 타입별 고유 로직이 추가될 때를 대비한 확장성 있는 구조입니다. (개방-폐쇄 원칙)
    *   **리팩토링 관점**: 현재는 비어있어 수정할 것이 없습니다.

*   **`BaseMonsterEquipment.cs` 분석:**
    *   **역할**: 모든 장비 타입의 기반이 되는 추상 `ScriptableObject` 클래스. 장비의 모든 공통 데이터와 핵심 기능을 정의합니다.
    *   **설계**: `IDamageModifier` 구현, 효과의 3단계 분리(`base`, `additional`, `unique`), `UniqueEffectSO`를 통한 전략 패턴 활용 등 매우 견고하고 유연하게 설계되었습니다.
    *   **리팩토링 관점**: 두 종류의 `ApplyTo` 오버로드(`DeterministicCharacterData`, `ICharacter`)가 존재하여 역할이 분리된 점 등 좋은 설계가 많습니다. 기반 클래스로서 훌륭합니다.

*   **`UniqueEffect.cs` 분석:**
    *   **역할**: 장비의 고유 효과(예: "체력 30% 이하일 때 공격력 증가")에 대한 모든 로직을 담고 있습니다.
    *   **설계**: 거대한 `switch` 문을 사용하여 모든 효과 로직을 한 곳에 모아두었습니다. 이는 개방-폐쇄 원칙(OCP)을 위반하는 안티패턴으로, 새로운 효과를 추가할 때마다 이 파일을 직접 수정해야 하므로 유지보수가 어렵습니다.
    *   **리팩토링 제안**: 각 효과를 별도의 전략 클래스로 분리하여 OCP를 준수하도록 리팩토링하는 것이 강력히 권장됩니다.
    
*   **`WeaponData.cs` 분석:**
    *   **역할**: 무기 타입을 정의하기 위한 뼈대 클래스입니다.
    *   **결론**: 클래스 자체는 정상이지만, 이 클래스의 인스턴스를 생성하는 다른 스크립트(`MonsterWeapon.cs`)에서 리플렉션을 사용하는 안티패턴이 발견되었습니다.

*   **`EquipmentEffect.cs` 분석:**
    *   **역할**: 장비가 부여하는 개별 효과("공격력 +10" 등)의 로직을 캡슐화합니다.
    *   **설계**: `StatModifierEffect`(고정값)와 `PercentStatModifierEffect`(비율값) 두 종류의 효과가 있습니다.
    *   **리팩토링 관점 (문제점)**: `PercentStatModifierEffect`가 `static` 전역 변수를 사용하여 상태를 추적합니다. 이는 **결정론적 시스템과 정면으로 충돌**하는 심각한 설계 결함으로, 반드시 수정되어야 합니다.

*   **`GlobalMonsterEquipmentManager.cs` 분석:**
    *   **역할**: 프로젝트에 존재하는 모든 장비 에셋의 '마스터 목록' 역할을 하는 `ScriptableObject`. 인스펙터에서 수동으로 리스트를 관리합니다.
    *   **리팩토링 관점 (문제점)**: `Managers/EquipmentManager.cs`와 **기능적으로 완벽히 중복**됩니다. 두 시스템의 공존은 혼란을 야기하므로 하나로 통합해야 합니다.

*   **`MonsterEquipmentManager.cs` 분석:**
    *   **역할**: 특정 캐릭터 한 명에게 귀속된 장비 슬롯을 관리하는 인스턴스 클래스.
    *   **리팩토링 관점 (문제점)**: 장비의 원본 에셋(`ScriptableObject`)을 직접 장착/참조합니다. 이는 "내 캐릭터의 +5 강철 검"과 같은 **개별 인스턴스의 상태를 표현할 수 없는 심각한 구조적 한계**를 가집니다. 장비 강화 시스템 구현을 위해 반드시 '인스턴스' 개념을 도입해야 합니다.

*   **`MonsterWeapon.cs` 분석:**
    *   **역할**: 무기 타입 에셋을 생성하는 클래스.
    *   **리팩토링 관점 (문제점)**: 부모 클래스의 `private` 필드에 접근하기 위해 **리플렉션(Reflection)을 사용**합니다. 이는 캡슐화를 파괴하는 매우 위험한 안티패턴으로, 반드시 제거해야 합니다.

---

## `Buff` 폴더

캐릭터에게 상태 이상이나 강화 효과를 부여하는 시스템입니다. 이전에 `BuffBlueprint`와 `StatBuffEffect`를 분석했으며, 나머지 파일들에 대한 분석입니다.

*   **`BuffManager.cs` 분석:**
    *   **역할**: 버프 시스템의 '총괄 관리자' 역할을 하는 싱글톤입니다. 게임 시작 시 모든 `BuffBlueprint`을 로드하고 `BuffEffectRegistry`를 초기화하며, 런타임에 `BuffData` 인스턴스를 생성하는 책임을 가집니다.
    *   **설계**: 데이터 로딩, 레지스트리 초기화, 런타임 인스턴스 생성이라는 세 가지 중요한 책임을 수행하며, 버프 시스템 전체가 원활하게 작동하도록 합니다.

*   **`IBuffEffect.cs` 분석:**
    *   **역할**: 모든 버프 효과 클래스가 구현해야 하는 생명주기(`OnApply`, `OnTick`, `OnRemove`, `OnReapply`) 메서드를 정의하는 인터페이스입니다.
    *   **설계**: 전략 패턴의 기반으로서, 다양한 종류의 버프 효과를 일관되고 확장 가능한 방식으로 구현할 수 있게 합니다. `ref BuffData` 파라미터 사용은 성능을 고려한 설계로 보입니다.

---

## `Localization` 폴더

매우 모범적인 설계를 보여주며, 리팩토링이 거의 필요 없는 시스템입니다.

*   **`ILocalizationLogger.cs`, `LanguageSettings.cs` 분석:**
    *   각각 로깅 추상화와 언어 설정 데이터화를 훌륭하게 수행합니다. SOLID 원칙을 잘 따르는 좋은 예시입니다.

*   **`LocalizationManager.cs`, `LocalizationCore.cs` 분석:**
    *   **역할 분리**: `LocalizationManager`(Unity 연동 래퍼)와 `LocalizationCore`(순수 C# 핵심 로직)로 역할을 완벽하게 분리하여 테스트 용이성과 이식성을 극대화했습니다.
    *   **설계**: 의존성 주입, 이벤트, 캐싱 등 성숙한 소프트웨어 설계 기법이 모두 적용되어 있습니다.

*   **`StringTable.cs` 분석:**
    *   **역할**: 실제 텍스트 데이터를 저장하는 `ScriptableObject`.
    *   **설계**: 에디터 편의성(배열)과 런타임 성능(캐시) 사이의 균형을 맞춘 좋은 설계입니다. 에디터 전용 코드도 잘 활용하고 있습니다.

---

## `Managers` 폴더

게임의 고수준 관리자 클래스들을 포함하며, 일부 중복 및 역할 분리 문제가 있습니다.

*   **`EquipmentManager.cs` 분석:**
    *   **역할**: `Resources.LoadAll`을 통해 장비 데이터베이스를 자동으로 구축하는 순수 C# 싱글톤.
    *   **리팩토링 관점 (문제점)**: `GlobalMonsterEquipmentManager`와 **기능이 중복**되므로 통합이 필요합니다. 자동 로드 방식이 더 효율적이므로 이 클래스를 유지하는 방향이 권장됩니다.

*   **`GameManager.cs` 분석:**
    *   **역할**: 현재는 게임 관리자라기보다는 '전투 테스트 시작' 기능에 국한되어 있습니다.
    *   **리팩토링 관점**: 클래스 이름과 실제 역할이 일치하지 않습니다. 또한 사용자 규칙에 따라, **테스트 전용 코드(`TestParticipant` 등)는 별도의 파일/모듈로 분리**해야 합니다.

---

## `Character` 폴더

캐릭터의 성장 시스템, 데이터 구조, 시각적 표현(View) 등을 포함합니다. 이전에 `CharacterGrowthSystem`과 `GrowthManager`를 분석했으며, 나머지 파일들에 대한 분석입니다.

*   **`ClientMonster.cs` 분석:**
    *   **역할**: 결정론적 데이터(`DeterministicCharacterData`)를 Unity 씬에서 시각적으로 표현하는 '뷰(View)' 클래스입니다.
    *   **설계**: MVC 아키텍처의 View 역할을 완벽하게 수행합니다. 데이터와 로직으로부터 뷰를 완벽하게 분리하여, 유지보수성과 테스트 용이성을 크게 향상시킵니다. 데이터 주도(Data-Driven) 방식으로 외부에서 주입된 상태를 화면에 반영하며, `CharacterViewFactory`와 협력하여 오브젝트 풀링을 지원합니다.
    
*   **`ICharacter.cs` 분석:**
    *   **역할**: 모든 캐릭터 '뷰' 객체가 구현해야 하는 공통 규약을 정의하는 인터페이스입니다.
    *   **설계**: 의존성 역전 원칙(DIP)의 훌륭한 예시입니다. `BattleManager`와 같은 상위 모듈이 구체적인 뷰 클래스가 아닌 이 인터페이스에 의존하게 하여 시스템의 결합도를 낮추고 유연성을 향상시킵니다.

*   **`GradeGrowthConfig.cs` 분석:**
    *   **역할**: 캐릭터 등급별 스탯 성장률의 범위를 정의하는 데이터 기반 `ScriptableObject` 설정 테이블입니다.
    *   **결론**: 이 설정 파일 자체는 잘 설계되었지만, `GrowthManager`가 이 데이터를 비결정론적인 `UnityEngine.Random`과 함께 사용했던 것이 문제의 핵심이었습니다.

*   **기타 파일 분석 (`CharacterTypes.cs`, `ElementType.cs`, `StatType.cs`):**
    *   **역할**: 캐릭터의 각종 속성(등급, 원소, 스탯 종류 등)을 정의하는 `enum`과 관련 데이터 구조체들을 포함합니다.
    *   **설계**: 게임 디자인의 핵심 분류 기준을 코드로 명확하게 정의하고, `[Serializable]` 속성과 `StatValue` 같은 구조체를 통해 Unity 인스펙터에서의 데이터 입력을 편리하게 만듭니다.

---

## `Shared` 폴더

여러 시스템에서 공통으로 사용되는 매우 잘 설계된 유틸리티성 코드를 포함합니다.

*   **`Scaling` 시스템 (`IndividualScaling.cs`, `IScalingStrategy.cs`, `ScalingStrategyFactory.cs`) 분석:**
    *   **설계**: 전략 패턴과 팩토리 패턴을 교과서적으로 활용하여, 레벨에 따른 값의 증가 로직을 매우 유연하고 확장 가능하게 만들었습니다.
    *   **리팩토링 관점**: 매우 잘 설계되어 리팩토링이 필요 없습니다.

*   **`ScalingConfig.cs` 와 `ScalingType.cs` 분석:**
    *   **역할**: 다양한 스케일링 전략에 필요한 모든 설정값을 담는 `ScalingConfig` 데이터 구조체와, 스케일링 방식을 정의하는 `ScalingType` enum을 포함합니다.
    *   **설계**: `[Serializable]` 구조체를 통해 Unity 인스펙터에서 성장 방식을 시각적으로 설정할 수 있게 하는, 유연하고 잘 구성된 데이터 구조입니다.

---

## `Skill` 폴더

실행 로직은 훌륭하나, 관리자 클래스에서 심각한 안티패턴이 발견되었습니다.

*   **`BuffStrategy.cs`, `DamageStrategy.cs` 분석:**
    *   **역할**: 스킬 효과(버프, 데미지)를 실행하는 전략 클래스.
    *   **설계**: 결정론적 원칙(상태 복제)을 잘 따르고, 다른 시스템(데미지 계산기, 버프 관리자)에 책임을 위임하는 등 매우 잘 설계되었습니다.

*   **`SkillData.cs` 분석:**
    *   **역할**: 스킬 하나의 모든 정적 데이터를 담는 거대한 `ScriptableObject`.
    *   **설계**: `Scaling` 시스템 통합, `SkillDataCache`를 통한 성능 최적화 등 많은 기능이 포함되어 있습니다. 클래스가 비대하므로 역할에 따라 내부 클래스로 분리하는 것을 고려해볼 수 있습니다.

*   **`SkillManager.cs` 분석:**
    *   **역할**: 모든 스킬 에셋을 관리하는 데이터베이스.
    *   **리팩토링 관점 (문제점)**:
        1.  '기본 공격' 스킬을 런타임에 `ScriptableObject.CreateInstance`로 생성하여 **사용자 규칙을 위반**하고 있습니다.
        2.  생성된 객체의 `private` 필드를 수정하기 위해 **리플렉션을 사용**하는 심각한 안티패턴을 포함하고 있습니다. 이 부분은 반드시 재설계되어야 합니다.

---

## `Utility` 폴더

프로젝트 전반의 코드 품질을 높이는 유용한 헬퍼 클래스들을 포함합니다.

*   **`DictionaryExtensions.cs`, `GameLogger.cs` 분석:**
    *   코드의 가독성과 안전성을 높이고, 조건부 컴파일을 통해 빌드를 최적화하는 등 실용적이고 효과적인 유틸리티입니다. 리팩토링이 필요 없습니다. 

---

## `Battle` 폴더

결정론적 전투 시스템의 핵심 로직과 뷰(View)를 연결하는 클래스들을 포함합니다. 이전에 분석한 `BattleManager`, `DeterministicBattleRules`, `AttackAction` 외 나머지 파일들에 대한 분석입니다.

*   **`IAction.cs` 분석:**
    *   **역할**: 전투 중 발생하는 모든 개별 행동(공격, 스킬)이 따라야 하는 표준 규약을 정의하는 인터페이스입니다.
    *   **설계**: 전형적인 커맨드 패턴(Command Pattern)을 따릅니다. `Execute` 메서드는 순수 함수처럼 동작하여 현재 상태를 받아 새로운 상태를 반환하며, 이는 결정론적 시스템의 핵심 원칙을 인터페이스 수준에서 강제합니다.
    *   **결론**: 전투 행동을 처리하기 위한 매우 견고하고 유연하며 확장 가능한 기반을 제공합니다.

*   **`SkillAction.cs` 분석:**
    *   **역할**: 스킬 사용을 나타내는 `IAction` 구현체입니다.
    *   **설계**: `AttackAction`과 마찬가지로 불변성을 유지하며, 핵심 로직으로 전략 패턴(Strategy Pattern)을 사용합니다. `SkillEffectStrategyFactory`를 통해 각 스킬 효과에 맞는 전략(`DamageStrategy`, `BuffStrategy` 등)을 가져와 실행합니다. 이는 새로운 스킬 효과를 추가할 때 기존 코드를 수정할 필요가 없게 만드는, OCP를 준수하는 훌륭한 설계입니다.
    *   **리팩토링 관점**: `AttackAction`과 마찬가지로 싱글톤 팩토리(`SkillEffectStrategyFactory.Instance`)에 직접 의존하여 테스트 용이성과 모듈성을 저해하는 아키텍처 결함을 가지고 있습니다.

*   **`BattleEvent.cs` 및 `BattleEventType.cs` 분석:**
    *   **역할**: 결정론적 엔진에서 발생한 특정 사건(데미지, 힐, 버프 적용 등)을 나타내는 순수 데이터 `struct`와 이벤트 종류를 정의하는 `enum`입니다.
    *   **설계**: `struct`와 `readonly` 필드를 사용하여 작고 효율적이며 불변하는 데이터 전송 객체(DTO)를 만듭니다. 이는 결정론적 로직과 Unity 뷰 사이의 통신을 위한 훌륭한 관심사 분리 예시입니다.

*   **`CharacterViewFactory.cs` 분석:**
    *   **역할**: 캐릭터의 시각적 표현(프리팹)을 생성하고 관리하는 `ICharacterFactory` 구현체입니다.
    *   **설계**: 오브젝트 풀링(Object Pooling)을 구현하여 `Instantiate`와 `Destroy` 호출을 최소화하고 성능을 최적화합니다. 데이터 기반 설정, 인터페이스 기반 설계, 견고한 예외 처리 등 좋은 설계 관행을 잘 따르는 매우 훌륭한 예시입니다.

*   **`DefaultVictoryConditionChecker.cs` 분석:**
    *   **역할**: "한쪽 진영의 전멸"이라는 기본 승리 조건을 확인하는 `IVictoryConditionChecker` 구현체입니다.
    *   **설계**: 더 큰 전략 패턴의 일부로, 다른 승리 조건을 가진 새로운 체커로 쉽게 교체할 수 있습니다. 상태를 갖지 않고 입력값에 대해서만 결과를 반환하는 단순하고 확장 가능한 클래스입니다.

*   **`AIActionInputProvider.cs` 분석:**
    *   **역할**: AI 캐릭터의 행동을 결정하는 `IActionInputProvider` 구현체입니다.
    *   **설계**: 현재는 "사용 가능한 스킬 우선, 없으면 기본 공격"이라는 단순한 로직을 가지고 있습니다. 가장 중요한 설계 결정은 타겟팅 시 `UnityEngine.Random`이 아닌 `battleRules.GetRandomInt()`를 사용하여 **결정론적 랜덤을 보장**한다는 점입니다. 이는 전체 시스템의 결정론을 유지하는 데 필수적입니다.

---

## `Battle/Damage` 폴더

데미지 계산 파이프라인을 구성하는 각 단계를 포함합니다. 책임 연쇄 패턴을 매우 효과적으로 활용하여 복잡한 데미지 공식을 여러 개의 독립적이고 재사용 가능한 단계로 나눈, 프로젝트에서 가장 잘 설계된 부분 중 하나입니다.

*   **`IDamageCalculationStep.cs`와 `DamageCalculationContext.cs` 분석:**
    *   **역할**: 모든 계산 단계가 따라야 하는 `IDamageCalculationStep` 인터페이스와, 파이프라인을 통해 전달되며 계산 상태를 저장하는 `DamageCalculationContext` 컨텍스트 객체를 정의합니다.
    *   **설계**: 중앙화된 컨텍스트 객체를 사용하여 각 단계의 인터페이스를 단순화하고, 단계 간 데이터 공유를 용이하게 합니다. 의도적으로 가변적인 컨텍스트 객체를 계산 범위 내에서만 사용하여 효율성과 시스템의 전반적인 불변성을 모두 달성하는 훌륭한 설계입니다.

*   **파이프라인 단계 분석 (`BaseDamageStep` ~ `ModifierStep`):**
    *   **책임 분리**: 각 단계는 '기본 데미지 계산', '치명타 적용', '방어 관통 계산', '속성 상성 적용' 등 단 하나의 명확한 책임을 가집니다.
    *   **의존성 주입**: `CriticalDamageStep`과 `ElementalAffinityStep`은 각각 결정론적 `Random`과 `ElementalAffinityTable`을 생성자에서 주입받습니다. 이는 테스트 용이성과 유연성을 크게 높이는 좋은 설계입니다.
    *   **순서의 중요성**: 파이프라인은 '주는 피해량 증가' 단계들 -> '받는 피해량 감소' 단계들 -> '최종 보정' 단계 순서로 논리적으로 구성되어 있습니다.
    *   **기술 부채 식별**: `ModifierStep`의 `TODO` 주석은 새로운 파이프라인과 레거시 `IDamageModifier`를 연결하기 위한 임시방편을 명확히 인지하고 있으며, 향후 리팩토링 지점을 알려줍니다.

*   **결론**: 데미지 계산 시스템은 프로젝트 전체의 모범 사례로 삼을 만한, 매우 성숙하고 전문적인 설계를 보여줍니다. 